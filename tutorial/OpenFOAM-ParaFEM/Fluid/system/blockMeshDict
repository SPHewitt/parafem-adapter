/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | foam-extend: Open Source CFD                    |
|  \\    /   O peration     | Version:     3.0                                |
|   \\  /    A nd           | Web:         http://www.extend-project.de       |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      blockMeshDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

convertToMeters 1;

// D is the dimensionaless Parameter with which the the domain is scaled.

// Changeable Parameters
// -------------------------------------------
// flap height
 D 1.0;
// flap width			
 h 4.0;

// Domain Parameters
// -------------------------------------------

// Total Domain Length
 L #calc "24*$D";

// Total Domain Height		
 H #calc "$h+(6*$D)";

// Total Domain Width (Unused)
 W #calc "16*$D";

// Distance Upstream			
 upstream #calc "6*$D";
 upstreamN #calc "-6*$D";

// Distance Dowstream		
 downstream #calc "18*$D";

// Distance Spanwise
 spanwise #calc "8*$D";
 spanwiseN #calc "-8*$D";

// Coordinate Parameters
 A #calc "-1.0*($D/2.0)";
 B #calc "($D/2.0)";

// Verticies
// -------------------------------------------

vertices
(
    //Level 0	
    ($upstreamN  0 	$spanwiseN)	// 0
    ($A 	 0 	$spanwiseN)	// 1
    ($B	  	 0 	$spanwiseN)	// 2
    ($downstream 0 	$spanwiseN)	// 3

    ($upstreamN  $h 	$spanwiseN)	// 4
    ($A 	 $h 	$spanwiseN)	// 5
    ($B  	 $h 	$spanwiseN)	// 6
    ($downstream $h	$spanwiseN)	// 7

    ($upstreamN  $H 	$spanwiseN)	// 8
    ($A          $H 	$spanwiseN)	// 9
    ($B          $H 	$spanwiseN)	// 10
    ($downstream $H 	$spanwiseN)	// 11

    //Level 1
    ($upstreamN  0 	$A)	// 12
    ($A 	 0 	$A)	// 13
    ($B	  	 0 	$A)	// 14
    ($downstream 0 	$A)	// 15

    ($upstreamN  $h 	$A)	// 16
    ($A 	 $h 	$A)	// 17
    ($B  	 $h 	$A)	// 18
    ($downstream $h 	$A)	// 19

    ($upstreamN  $H   	$A)	// 20
    ($A          $H   	$A)	// 21
    ($B          $H   	$A)	// 22
    ($downstream $H   	$A)	// 23

    //Level 2
    ($upstreamN  0 	$B)	// 24
    ($A 	 0 	$B)	// 25
    ($B	  	 0 	$B)	// 26
    ($downstream 0 	$B)	// 27

    ($upstreamN  $h 	$B)	// 28
    ($A 	 $h 	$B)	// 29
    ($B  	 $h 	$B)	// 30
    ($downstream $h 	$B)	// 31

    ($upstreamN  $H   	$B)	// 32
    ($A          $H   	$B)	// 33
    ($B          $H   	$B)	// 34
    ($downstream $H   	$B)	// 35


    //Level 3
    ($upstreamN  0 	$spanwise)	// 36
    ($A 	 0 	$spanwise)	// 37
    ($B	  	 0 	$spanwise)	// 38
    ($downstream 0 	$spanwise)	// 39

    ($upstreamN  $h 	$spanwise)	// 40
    ($A 	 $h 	$spanwise)	// 41
    ($B		 $h 	$spanwise)	// 42
    ($downstream $h 	$spanwise)	// 43

    ($upstreamN  $H   	$spanwise)	// 44
    ($A          $H   	$spanwise)	// 45
    ($B          $H   	$spanwise)	// 46
    ($downstream $H   	$spanwise)	// 47
);


// y = 0
//		6 7 8 
// Inflow -> 	4   5	
//		1 2 3
//
// y = +
//	  	15 16 17
// Inflow -> 	12 13 14
//		9  10 11

// Note Left of flap and right of flap are same
// therefore LFlap can be used for size of RFlap
// Be aware fo definition of RFlap above.

//course mesh cells 2.5cm 
//fine mesh cells 1.0cm

// Set Cell Size
// level 1 - 0.13
// level 2 - 0.11
// level 3 - 0.1
// level 4 - 0.088
 cs 0.11;

// Set variable for height above flap
 top #calc "$H-$h";

// For ease of Reading
// Depths (x)
 bef # calc "int(std::ceil($upstream/$cs))";
 sid # calc "int(std::ceil(($D/$cs)*4.0))";
 beh # calc "int(std::ceil($downstream/$cs))";

// Heights (Y)
 bt  # calc "int(std::ceil(($h/$cs)*2.4))";
 tp  # calc "int(std::ceil($top/$cs))";

// Widths (Z)
 left # calc "int(std::ceil($spanwise/$cs))";
 righ # calc "int(std::ceil($spanwise/$cs))";
 flp # calc "int(std::ceil(($D/$cs)*4.0))";


// Grading
// gradybtm  15;
// gradytop = 0.2



// simpleGrading
//    (
//        1                  // xDNirection expansion ratio
//        (
//            (0.2 0.3 4)    // 20% yDNir, 30% cells, expansion = 4
//            (0.6 0.4 1)    // 60% yDNir, 40% cells, expansion = 1
//            (0.2 0.3 0.25) // 20% yDNir, 30% cells, expansion = 0.25 (1/4)
//        )
//        3                  // zDNirection expansion ratio
//    )


gradxA ((65 35 1) (35 65 0.02));
//gradxB ((30 60 5) (70 40 3));
gradxB ((35 70 10) (70 30 3));

gradytop ((100 100 25));

gradybtm ((8 15 10) (84 70 1) (8 15 0.3));
//gradybtm ((50 50 8) (50 50 0.125));

// First Runs
//gradzA  ((100 100 0.04));
//gradzB  ((100 100 25));

gradzA  ((100 100 0.022));
gradzB  ((100 100 45));



blocks
(
    
    hex (0 1 5 4 12 13 17 16) ($bef $bt $left) simpleGrading ($gradxA $gradybtm $gradzA)    	// block 0
    hex (1 2 6 5 13 14 18 17) ($sid $bt $left) simpleGrading  (1 $gradybtm $gradzA)	// block 1
    hex (2 3 7 6 14 15 19 18) ($beh $bt $left) simpleGrading ($gradxB $gradybtm $gradzA)	// block 2

    hex (12 13 17 16 24 25 29 28) ($bef $bt $flp) simpleGrading ($gradxA $gradybtm 1)     	// block 3
    hex (14 15 19 18 26 27 31 30) ($beh $bt $flp) simpleGrading ($gradxB $gradybtm 1)     	// block 4

    hex (24 25 29 28 36 37 41 40) ($bef $bt $righ) simpleGrading ($gradxA $gradybtm $gradzB)  // block 5
    hex (25 26 30 29 37 38 42 41) ($sid $bt $righ) simpleGrading (1 $gradybtm $gradzB)  // block 6
    hex (26 27 31 30 38 39 43 42) ($beh $bt $righ) simpleGrading ($gradxB $gradybtm $gradzB) 	// block 7 

// UpperDeck
    hex (4 5 9 8 16 17 21 20) ($bef $tp $left) simpleGrading ($gradxA $gradytop $gradzA)    	// block 8
    hex (5 6 10 9 17 18 22 21) ($sid $tp $left) simpleGrading (1 $gradytop $gradzA) 	// block 9
    hex (6 7 11 10 18 19 23 22) ($beh $tp $left) simpleGrading ($gradxB $gradytop $gradzA)  	// block 10 

    hex (16 17 21 20 28 29 33 32) ($bef $tp $flp) simpleGrading ($gradxA $gradytop 1)     	// block 11
    hex (17 18 22 21 29 30 34 33) ($sid $tp $flp) simpleGrading (1 $gradytop 1)
    hex (18 19 23 22 30 31 35 34) ($beh $tp $flp) simpleGrading ($gradxB $gradytop 1)  	// block 12 

    hex (28 29 33 32 40 41 45 44) ($bef $tp $righ) simpleGrading ($gradxA $gradytop $gradzB)   // block 13
    hex (29 30 34 33 41 42 46 45) ($sid $tp $righ) simpleGrading (1 $gradytop $gradzB)   // block 14
    hex (30 31 35 34 42 43 47 46) ($beh $tp $righ) simpleGrading ($gradxB $gradytop $gradzB)   // block 15

);

edges
(
);

boundary
(
	inlet
	{
		type	patch;
		faces	
		(
			(4 16 20 8)
			(0 12 16 4)
			(12 24 28 16)
			(16 28 32 20)
			(24 36 40 28)
			(28 40 44 32)
		);
	}
	outlet
	{
		type	patch;
		faces	
		(
			(31 35 47 43)
			(27 31 43 39)
			(15 19 31 27)
			(19 23 35 31)
			(7 11 23 19)
			(3 7 19 15)
		);
	}
	top
	{
		type	wall;
		faces	
		(
			(8 20 21 9)
			(9 21 22 10)
			(10 22 23 11)
			(20 32 33 21)
                        (21 22 34 33)
			(32 44 45 33)
			(33 45 46 34)
			(22 34 35 23)
			(34 46 47 35)
		);
	}
	bottom
	{
		type	wall;
		faces	
		(
			(24 25 37 36)
			(25 26 38 37)
			(26 27 39 38)
			(14 15 27 26)
			(12 13 25 24)
			(0 1 13 12)
			(1 2 14 13)
			(2 3 15 14)
		);
	}
	interface
	{
		type	wall;
		faces	
		(
        (14 18 17 13)
	(13 17 29 25)
	(25 29 30 26)
     	(26 30 18 14)
	(17 18 30 29)
		);
	}
	front
	{
		type	wall;
		faces	
		(
			(6 10 11 7)
			(5 9 10 6)
			(4 8 9 5)
			(0 4 5 1)
			(1 5 6 2)
			(2 6 7 3)
		);
	}
	back
	{
		type	wall;
		faces	
		(
			(40 41 45 44)
			(42 43 47 46)
			(38 39 43 42)
			(37 38 42 41)
			(41 42 46 45)
			(36 37 41 40)
		);
	}
);

mergePatchPairs
(
);

// ************************************************************************* //
